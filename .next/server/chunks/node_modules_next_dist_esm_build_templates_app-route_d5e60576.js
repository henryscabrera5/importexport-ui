module.exports=[33010,e=>{"use strict";var t=e.i(47909),a=e.i(74017),n=e.i(96250),i=e.i(59756),r=e.i(61916),o=e.i(14444),s=e.i(37092),c=e.i(69741),l=e.i(16795),d=e.i(87718),u=e.i(95169),m=e.i(47587),p=e.i(66012),f=e.i(70101),h=e.i(26937),g=e.i(10372),b=e.i(93695);e.i(52474);var E=e.i(5232),y=e.i(89171),v=e.i(29642);let x=process.env.GEMINI_API_KEY;x||console.warn("GEMINI_API_KEY is not set. Document processing will not work.");let C=x?new v.GoogleGenerativeAI(x):null;async function R(e){try{let t,a,n;if(!C)return y.NextResponse.json({error:"Gemini API key not configured"},{status:500});let{fileData:i,fileName:r,mimeType:o,documentType:s}=await e.json();if(!i||!s)return y.NextResponse.json({error:"Missing required fields: fileData and documentType"},{status:400});let c=C.getGenerativeModel({model:"gemini-2.0-flash-exp"}),l=`Analyze this document and describe its structure, layout, and content type. 
Identify if it contains tables, lists, or structured data. 
For packing lists, identify if items are in a table format where each row represents one item.
Return a brief JSON summary: { "documentType": "...", "hasTables": true/false, "tableStructure": "description", "itemCount": number }`,d=await c.generateContent([l,{inlineData:{data:i,mimeType:o}}]),u=(await d.response).text();try{let e=u.match(/```json\n([\s\S]*?)\n```/)||u.match(/```\n([\s\S]*?)\n```/),a=e?e[1]:u;t=JSON.parse(a)}catch(e){t={rawText:u}}a="packing_list"===s?`You are an expert at extracting structured data from PACKING LISTS.

IMPORTANT: Packing lists typically contain items in a TABLE format where EACH ROW represents ONE ITEM.

Based on the document structure analysis, extract the following information:

1. Document Header Information (REQUIRED):
- packingListNumber: Packing list number (extract from document)
- invoiceNumber: Invoice number if referenced on packing list
- shipmentDate: Shipment date (YYYY-MM-DD format)
- currency: Currency code (e.g., "USD", "EUR", "CNY") if available

2. Shipper/Consignee Information (REQUIRED):
- seller (Shipper/Exporter): { 
    name: Company/business name,
    address: Complete exact address including street, city, state/province, postal code, country,
    taxId: Tax ID/VAT number if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available,
      fax: Fax number if available,
      contactPerson: Contact person name if available
    }
  } - Extract shipper/exporter/seller complete information
- buyer (Consignee): { 
    name: Company/business name,
    address: Complete exact address including street, city, state/province, postal code, country,
    taxId: Tax ID/VAT number if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available,
      fax: Fax number if available,
      contactPerson: Contact person name if available
    }
  } - Extract consignee/buyer complete information

3. Items/Products Table (REQUIRED):
The document contains a table where each ROW is one item. Extract ALL rows from the table.
For EACH ROW, create an entry in the products array with:
- description: Product/item description from the row (REQUIRED)
- quantity: Quantity as number (REQUIRED - extract from the row)
- unitOfMeasure: Unit of measure (e.g., "pcs", "kg", "m", "boxes", "cartons")
- unitPrice: Unit price as number (if available in the row)
- totalPrice: Total price for this line item (if available in the row)
- countryOfOrigin: Country being shipped from/origin (e.g., "CN", "US", "DE") - extract country code or name
- htsCode: HS Code (Harmonized System code) if available in the row - also known as HTS code
- packageNumber: Package/carton number if listed (Package Counts)
- packageCount: Number of packages/cartons for this item
- weight: Weight from the row (REQUIRED if available)
- weightUnit: Weight unit (e.g., "kg", "lbs")
- dimensions: Dimensions if available (length x width x height) - extract as string like "10x20x30 cm" or object
- length: Length dimension if available
- width: Width dimension if available
- height: Height dimension if available
- dimensionUnit: Unit for dimensions (e.g., "cm", "in", "m")
- currency: Currency code (e.g., "USD", "EUR") if available
- any other relevant fields from the table columns

4. Shipment Information:
- shipmentInfo: { 
    originCountry: Country being shipped from/origin (REQUIRED),
    originCity: Origin city if available,
    destinationCountry: Destination country,
    destinationCity: Destination city,
    carrier: Carrier name if available,
    containerNumber: Container number if available,
    vesselName: Vessel name if available,
    estimatedArrivalDate: Estimated arrival date if available,
    incoterms: Incoterms if applicable (e.g., "FOB", "CIF", "EXW", "DDP", "DAP", etc.)
  }

5. Document Signer Information:
- signer: {
    name: Full name of person signing the document,
    company: Company name of signer if different from seller,
    title: Job title/position if available,
    signature: Signature information if available,
    date: Date of signature if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available
    }
  } - Extract complete information about the person signing off on the document

6. Totals:
- totals: { 
    totalWeight: Total weight (REQUIRED if available),
    weightUnit: Weight unit,
    totalPackages: Total package count (REQUIRED if available),
    totalQuantity: Total quantity of items,
    totalValue: Total value if available,
    currency: Currency code
  }

7. Metadata:
- confidence: Your confidence score (0-1)

CRITICAL EXTRACTION REQUIREMENTS: 
- Extract EVERY row from the items table
- Each row should become one object in the products array
- Product Descriptions: Extract full product/item descriptions
- Quantities: Extract quantities as numbers
- Unit Prices and Totals: Extract both unit price and total price if available
- Shipper/Exporter/Consignee Names and Addresses: Extract complete exact addresses including street address, city, state/province, postal code, and country
- Contact Information: Extract phone, email, fax, and contact person for all parties (seller, buyer, signer)
- Signer Information: Extract name, company, title, signature details, and contact information for person signing the document
- Invoice Numbers: Extract invoice number if referenced on packing list
- Dates: Extract shipment date in YYYY-MM-DD format
- Currencies: Extract currency code (USD, EUR, etc.) if available
- Country being shipped from/origin: Extract origin country for each product and overall shipment
- HS Code: Extract HS/HTS codes if visible in the table rows
- Package Counts: Extract number of packages/cartons for each item and total
- Weights: Extract weight for each item and total weight
- Dimensions: Extract dimensions (length, width, height) for each item if available
- Incoterms: Extract incoterms if applicable (FOB, CIF, EXW, DDP, DAP, etc.)
- Preserve all information from each table row
- If the table has column headers, use them to identify what each column represents

Return ONLY valid JSON in this format:
{
  "packingListNumber": "...",
  "invoiceNumber": "...",
  "shipmentDate": "YYYY-MM-DD",
  "currency": "USD",
  "seller": { 
    "name": "...", 
    "address": "Complete exact address including street, city, state, postal code, country",
    "taxId": "...",
    "contact": {
      "phone": "...",
      "email": "...",
      "fax": "...",
      "contactPerson": "..."
    }
  },
  "buyer": { 
    "name": "...", 
    "address": "Complete exact address including street, city, state, postal code, country",
    "taxId": "...",
    "contact": {
      "phone": "...",
      "email": "...",
      "fax": "...",
      "contactPerson": "..."
    }
  },
  "signer": {
    "name": "Full name of signer",
    "company": "Company name",
    "title": "Job title",
    "signature": "Signature info if available",
    "date": "Signature date",
    "contact": {
      "phone": "...",
      "email": "..."
    }
  },
  "products": [
    { 
      "description": "...", 
      "quantity": 1,
      "unitPrice": 10.00,
      "totalPrice": 10.00,
      "countryOfOrigin": "CN",
      "htsCode": "8471.30.0100",
      "packageNumber": "PKG-001",
      "packageCount": 2,
      "weight": 5.5,
      "weightUnit": "kg",
      "dimensions": "10x20x30 cm",
      "length": 10,
      "width": 20,
      "height": 30,
      "dimensionUnit": "cm",
      ...
    },
    ...
  ],
  "shipmentInfo": { 
    "originCountry": "CN",
    "originCity": "...",
    "incoterms": "FOB",
    ...
  },
  "totals": { 
    "totalWeight": 100,
    "weightUnit": "kg",
    "totalPackages": 20,
    "totalQuantity": 50,
    "totalValue": 1000.00,
    "currency": "USD"
  },
  "confidence": 0.95
}

Return ONLY valid JSON, no markdown formatting or additional text.`:"commercial_invoice"===s?`You are an expert at extracting structured data from COMMERCIAL INVOICES.

IMPORTANT: Commercial invoices typically contain billed items in a TABLE format where EACH ROW represents ONE BILLED ITEM.

Based on the document structure analysis, extract the following information:

1. Document Header Information (REQUIRED):
- invoiceNumber: Invoice number (extract from document)
- invoiceDate: Invoice date (YYYY-MM-DD format)
- currency: Currency code (e.g., "USD", "EUR", "CNY") - extract from document

2. Shipper/Consignee Information (REQUIRED):
- seller (Shipper/Exporter): { 
    name: Company/business name,
    address: Complete exact address including street, city, state/province, postal code, country,
    taxId: Tax ID/VAT number if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available,
      fax: Fax number if available,
      contactPerson: Contact person name if available
    }
  } - Extract shipper/exporter/seller complete information
- buyer (Consignee): { 
    name: Company/business name,
    address: Complete exact address including street, city, state/province, postal code, country,
    taxId: Tax ID/VAT number if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available,
      fax: Fax number if available,
      contactPerson: Contact person name if available
    }
  } - Extract consignee/buyer complete information

3. Billed Items/Products Table (REQUIRED):
The document contains a table where each ROW is one billed item. Extract ALL rows from the table.
For EACH ROW, create an entry in the products array with:
- description: Product/item description from the row (REQUIRED)
- quantity: Quantity as number (REQUIRED - extract from the row)
- unitOfMeasure: Unit of measure (e.g., "pcs", "kg", "m", "boxes", "cartons")
- unitPrice: Unit price as number (REQUIRED - extract from the row)
- totalPrice: Total price for this line item (REQUIRED - extract from the row)
- countryOfOrigin: Country being shipped from/origin (e.g., "CN", "US", "DE") - extract country code or name
- htsCode: HS Code (Harmonized System code) if available in the row - also known as HTS code
- currency: Currency code (e.g., "USD", "EUR") - usually consistent across all items
- weight: Weight from the row (if available)
- weightUnit: Weight unit (e.g., "kg", "lbs")
- any other relevant fields from the table columns

4. Shipment Information:
- shipmentInfo: { 
    originCountry: Country being shipped from/origin (REQUIRED),
    originCity: Origin city if available,
    destinationCountry: Destination country,
    destinationCity: Destination city,
    carrier: Carrier name if available,
    containerNumber: Container number if available,
    vesselName: Vessel name if available,
    estimatedArrivalDate: Estimated arrival date if available,
    incoterms: Incoterms if applicable (e.g., "FOB", "CIF", "EXW", "DDP", "DAP", etc.)
  }

5. Document Signer Information:
- signer: {
    name: Full name of person signing the document,
    company: Company name of signer if different from seller,
    title: Job title/position if available,
    signature: Signature information if available,
    date: Date of signature if available,
    contact: {
      phone: Phone number if available,
      email: Email address if available
    }
  } - Extract complete information about the person signing off on the document

6. Totals:
- totals: { totalValue: Total invoice value (REQUIRED), totalWeight, currency }

7. Metadata:
- confidence: Your confidence score (0-1)

CRITICAL EXTRACTION REQUIREMENTS: 
- Extract EVERY row from the billed items table
- Each row should become one object in the products array
- Product Descriptions: Extract full product/item descriptions
- Quantities: Extract quantities as numbers
- Unit Prices and Totals: Extract both unit price and total price for each line item
- Shipper/Exporter/Consignee Names and Addresses: Extract complete exact addresses including street address, city, state/province, postal code, and country
- Contact Information: Extract phone, email, fax, and contact person for all parties (seller, buyer, signer)
- Signer Information: Extract name, company, title, signature details, and contact information for person signing the document
- Invoice Numbers: Extract invoice number from document header
- Dates: Extract invoice date in YYYY-MM-DD format
- Currencies: Extract currency code (USD, EUR, etc.)
- Country being shipped from/origin: Extract origin country for each product and overall shipment
- HS Code: Extract HS/HTS codes if visible in the table rows
- Incoterms: Extract incoterms if applicable (FOB, CIF, EXW, DDP, DAP, etc.)
- Preserve all information from each table row including pricing details
- If the table has column headers, use them to identify what each column represents
- Ensure currency is captured and applied consistently

Return ONLY valid JSON in this format:
{
  "invoiceNumber": "...",
  "invoiceDate": "YYYY-MM-DD",
  "currency": "USD",
  "seller": { 
    "name": "...", 
    "address": "Complete exact address including street, city, state, postal code, country",
    "taxId": "...",
    "contact": {
      "phone": "...",
      "email": "...",
      "fax": "...",
      "contactPerson": "..."
    }
  },
  "buyer": { 
    "name": "...", 
    "address": "Complete exact address including street, city, state, postal code, country",
    "taxId": "...",
    "contact": {
      "phone": "...",
      "email": "...",
      "fax": "...",
      "contactPerson": "..."
    }
  },
  "signer": {
    "name": "Full name of signer",
    "company": "Company name",
    "title": "Job title",
    "signature": "Signature info if available",
    "date": "Signature date",
    "contact": {
      "phone": "...",
      "email": "..."
    }
  },
  "products": [
    { 
      "description": "...", 
      "quantity": 1, 
      "unitPrice": 10.00, 
      "totalPrice": 10.00,
      "countryOfOrigin": "CN",
      "htsCode": "8471.30.0100",
      "currency": "USD",
      ...
    },
    ...
  ],
  "shipmentInfo": { 
    "originCountry": "CN",
    "originCity": "...",
    "destinationCountry": "US",
    "incoterms": "FOB",
    ...
  },
  "totals": { "totalValue": 1000.00, "totalWeight": 500, "currency": "USD" },
  "confidence": 0.95
}

Return ONLY valid JSON, no markdown formatting or additional text.`:`You are an expert at extracting structured data from import/export documents. 
Analyze the provided document and extract all relevant information. Return the data as a JSON object.`;let m=await c.generateContent([a,{inlineData:{data:i,mimeType:o}}]),p=(await m.response).text();try{let e=p.match(/```json\n([\s\S]*?)\n```/)||p.match(/```\n([\s\S]*?)\n```/),t=e?e[1]:p;n=JSON.parse(t)}catch(e){n={rawText:p,parseError:"Failed to parse JSON response"}}return n.documentUnderstanding=t,y.NextResponse.json({documentType:s,extractedData:n,confidence:n.confidence||.85,processingMetadata:{model:"gemini-2.0-flash-exp",extractionMethod:"gemini_vision",fileName:r}})}catch(e){return console.error("Error processing document:",e),y.NextResponse.json({error:"Failed to process document",message:e instanceof Error?e.message:"Unknown error"},{status:500})}}e.s(["POST",()=>R],83647);var I=e.i(83647);let w=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/process-documents/route",pathname:"/api/process-documents",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/process-documents/route.ts",nextConfigOutput:"",userland:I}),{workAsyncStorage:D,workUnitAsyncStorage:S,serverHooks:P}=w;function N(){return(0,n.patchFetch)({workAsyncStorage:D,workUnitAsyncStorage:S})}async function T(e,t,n){w.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let y="/api/process-documents/route";y=y.replace(/\/index$/,"")||"/";let v=await w.prepare(e,t,{srcPage:y,multiZoneDraftMode:!1});if(!v)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:x,params:C,nextConfig:R,parsedUrl:I,isDraftMode:D,prerenderManifest:S,routerServerContext:P,isOnDemandRevalidate:N,revalidateOnlyGenerated:T,resolvedPathname:U,clientReferenceManifest:O,serverActionsManifest:A}=v,k=(0,c.normalizeAppPath)(y),M=!!(S.dynamicRoutes[k]||S.routes[U]),Y=async()=>((null==P?void 0:P.render404)?await P.render404(e,t,I,!1):t.end("This page could not be found"),null);if(M&&!D){let e=!!S.routes[U],t=S.dynamicRoutes[k];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await Y();throw new b.NoFallbackError}}let H=null;!M||w.isDev||D||(H="/index"===(H=U)?"/":H);let F=!0===w.isDev||!M,_=M&&!F;A&&O&&(0,o.setReferenceManifestsSingleton)({page:y,clientReferenceManifest:O,serverActionsManifest:A,serverModuleMap:(0,s.createServerModuleMap)({serverActionsManifest:A})});let Q=e.method||"GET",L=(0,r.getTracer)(),W=L.getActiveScopeSpan(),q={params:C,prerenderManifest:S,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:F,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,n)=>w.onRequestError(e,t,n,P)},sharedContext:{buildId:x}},j=new l.NodeNextRequest(e),B=new l.NodeNextResponse(t),V=d.NextRequestAdapter.fromNodeNextRequest(j,(0,d.signalFromNodeResponse)(t));try{let o=async e=>w.handle(V,q).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=L.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=a.get("next.route");if(n){let t=`${Q} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${Q} ${y}`)}),s=!!(0,i.getRequestMeta)(e,"minimalMode"),c=async i=>{var r,c;let l=async({previousCacheEntry:a})=>{try{if(!s&&N&&T&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let r=await o(i);e.fetchMetrics=q.renderOpts.fetchMetrics;let c=q.renderOpts.pendingWaitUntil;c&&n.waitUntil&&(n.waitUntil(c),c=void 0);let l=q.renderOpts.collectedTags;if(!M)return await (0,p.sendResponse)(j,B,r,q.renderOpts.pendingWaitUntil),null;{let e=await r.blob(),t=(0,f.toNodeOutgoingHttpHeaders)(r.headers);l&&(t[g.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==q.renderOpts.collectedRevalidate&&!(q.renderOpts.collectedRevalidate>=g.INFINITE_CACHE)&&q.renderOpts.collectedRevalidate,n=void 0===q.renderOpts.collectedExpire||q.renderOpts.collectedExpire>=g.INFINITE_CACHE?void 0:q.renderOpts.collectedExpire;return{value:{kind:E.CachedRouteKind.APP_ROUTE,status:r.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:n}}}}catch(t){throw(null==a?void 0:a.isStale)&&await w.onRequestError(e,t,{routerKind:"App Router",routePath:y,routeType:"route",revalidateReason:(0,m.getRevalidateReason)({isStaticGeneration:_,isOnDemandRevalidate:N})},P),t}},d=await w.handleResponse({req:e,nextConfig:R,cacheKey:H,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:S,isRoutePPREnabled:!1,isOnDemandRevalidate:N,revalidateOnlyGenerated:T,responseGenerator:l,waitUntil:n.waitUntil,isMinimalMode:s});if(!M)return null;if((null==d||null==(r=d.value)?void 0:r.kind)!==E.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(c=d.value)?void 0:c.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",N?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),D&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let u=(0,f.fromNodeOutgoingHttpHeaders)(d.value.headers);return s&&M||u.delete(g.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||u.get("Cache-Control")||u.set("Cache-Control",(0,h.getCacheControlHeader)(d.cacheControl)),await (0,p.sendResponse)(j,B,new Response(d.value.body,{headers:u,status:d.value.status||200})),null};W?await c(W):await L.withPropagatedContext(e.headers,()=>L.trace(u.BaseServerSpan.handleRequest,{spanName:`${Q} ${y}`,kind:r.SpanKind.SERVER,attributes:{"http.method":Q,"http.target":e.url}},c))}catch(t){if(t instanceof b.NoFallbackError||await w.onRequestError(e,t,{routerKind:"App Router",routePath:k,routeType:"route",revalidateReason:(0,m.getRevalidateReason)({isStaticGeneration:_,isOnDemandRevalidate:N})}),M)throw t;return await (0,p.sendResponse)(j,B,new Response(null,{status:500})),null}}e.s(["handler",()=>T,"patchFetch",()=>N,"routeModule",()=>w,"serverHooks",()=>P,"workAsyncStorage",()=>D,"workUnitAsyncStorage",()=>S],33010)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_d5e60576.js.map