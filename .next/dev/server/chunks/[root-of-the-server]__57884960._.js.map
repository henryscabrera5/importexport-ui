{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/jseyoum21/Downloads/importexport-ui-main/app/api/get-latest-documents/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { createClient } from \"@supabase/supabase-js\"\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"\"\n\n/**\n * GET /api/get-latest-documents\n * Fetch the latest processed documents for the authenticated user from Supabase\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const authHeader = request.headers.get(\"authorization\")\n    if (!authHeader) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    // Extract token from \"Bearer <token>\"\n    const token = authHeader.replace(\"Bearer \", \"\")\n\n    // Create Supabase client with user's token\n    const supabase = createClient(supabaseUrl, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"\", {\n      global: {\n        headers: {\n          Authorization: authHeader,\n        },\n      },\n    })\n\n    // Get the authenticated user\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser(token)\n\n    if (userError || !user) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    // Fetch latest documents with parsed data\n    const { data: documents, error: documentsError } = await supabase\n      .from(\"documents\")\n      .select(\n        `\n        id,\n        file_name,\n        file_type,\n        file_size,\n        status,\n        created_at,\n        document_parsed_data (\n          id,\n          parsed_json,\n          extraction_confidence,\n          extraction_method,\n          created_at\n        )\n      `,\n      )\n      .eq(\"user_id\", user.id)\n      .eq(\"status\", \"processed\")\n      .order(\"created_at\", { ascending: false })\n      .limit(1) // Get only the most recent document\n\n    if (documentsError) {\n      console.error(\"Error fetching documents:\", documentsError)\n      return NextResponse.json(\n        { error: \"Failed to fetch documents\", details: documentsError.message },\n        { status: 500 },\n      )\n    }\n\n    // Transform the data to match the ProcessedDocument format\n    // NOTE: Handle both nested structure (parsed_json.extractedData) and flat structure (parsed_json is extractedData)\n    const processedDocuments = documents\n      ?.filter((doc) => doc.document_parsed_data && Array.isArray(doc.document_parsed_data) && doc.document_parsed_data.length > 0)\n      .map((doc) => {\n        const parsedData = Array.isArray(doc.document_parsed_data) ? doc.document_parsed_data[0] : doc.document_parsed_data\n        const parsedJson = parsedData?.parsed_json || {}\n        \n        // Determine document type and extracted data structure\n        const documentType = parsedJson.documentType || \"commercial_invoice\"\n        const extractedData = parsedJson.extractedData || parsedJson // Use extractedData if available, otherwise use parsedJson directly\n        \n        return {\n          documentId: doc.id,\n          fileName: doc.file_name,\n          documentType: documentType,\n          extractedData: extractedData,\n          confidence: (parsedData?.extraction_confidence || 0) / 100, // Convert from percentage\n          processingMetadata: {\n            processingTime: 0,\n            model: \"gemini-2.0-flash-exp\",\n            extractionMethod: parsedData?.extraction_method || \"gemini_vision\",\n            fileName: doc.file_name,\n          },\n          createdAt: doc.created_at,\n        }\n      }) || []\n\n    return NextResponse.json({\n      documents: processedDocuments,\n      count: processedDocuments.length,\n    })\n  } catch (error) {\n    console.error(\"Error in get-latest-documents:\", error)\n    return NextResponse.json(\n      {\n        error: \"Failed to fetch documents\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 },\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,cAAc,gFAAwC;AAMrD,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QACvC,IAAI,CAAC,YAAY;YACf,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,sCAAsC;QACtC,MAAM,QAAQ,WAAW,OAAO,CAAC,WAAW;QAE5C,2CAA2C;QAC3C,MAAM,WAAW,IAAA,yMAAY,EAAC,aAAa,wPAA6C,IAAI;YAC1F,QAAQ;gBACN,SAAS;oBACP,eAAe;gBACjB;YACF;QACF;QAEA,6BAA6B;QAC7B,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,OAAO,SAAS,EACjB,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO,CAAC;QAEhC,IAAI,aAAa,CAAC,MAAM;YACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,0CAA0C;QAC1C,MAAM,EAAE,MAAM,SAAS,EAAE,OAAO,cAAc,EAAE,GAAG,MAAM,SACtD,IAAI,CAAC,aACL,MAAM,CACL,CAAC;;;;;;;;;;;;;;MAcH,CAAC,EAEA,EAAE,CAAC,WAAW,KAAK,EAAE,EACrB,EAAE,CAAC,UAAU,aACb,KAAK,CAAC,cAAc;YAAE,WAAW;QAAM,GACvC,KAAK,CAAC,GAAG,oCAAoC;;QAEhD,IAAI,gBAAgB;YAClB,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAA6B,SAAS,eAAe,OAAO;YAAC,GACtE;gBAAE,QAAQ;YAAI;QAElB;QAEA,2DAA2D;QAC3D,mHAAmH;QACnH,MAAM,qBAAqB,WACvB,OAAO,CAAC,MAAQ,IAAI,oBAAoB,IAAI,MAAM,OAAO,CAAC,IAAI,oBAAoB,KAAK,IAAI,oBAAoB,CAAC,MAAM,GAAG,GAC1H,IAAI,CAAC;YACJ,MAAM,aAAa,MAAM,OAAO,CAAC,IAAI,oBAAoB,IAAI,IAAI,oBAAoB,CAAC,EAAE,GAAG,IAAI,oBAAoB;YACnH,MAAM,aAAa,YAAY,eAAe,CAAC;YAE/C,uDAAuD;YACvD,MAAM,eAAe,WAAW,YAAY,IAAI;YAChD,MAAM,gBAAgB,WAAW,aAAa,IAAI,WAAW,oEAAoE;;YAEjI,OAAO;gBACL,YAAY,IAAI,EAAE;gBAClB,UAAU,IAAI,SAAS;gBACvB,cAAc;gBACd,eAAe;gBACf,YAAY,CAAC,YAAY,yBAAyB,CAAC,IAAI;gBACvD,oBAAoB;oBAClB,gBAAgB;oBAChB,OAAO;oBACP,kBAAkB,YAAY,qBAAqB;oBACnD,UAAU,IAAI,SAAS;gBACzB;gBACA,WAAW,IAAI,UAAU;YAC3B;QACF,MAAM,EAAE;QAEV,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,WAAW;YACX,OAAO,mBAAmB,MAAM;QAClC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}